### Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.


ðŸŽ¯ Key Observations
1. Preorder traversal (Root â†’ Left â†’ Right) â†’ First element is always the root.
2. Inorder traversal (Left â†’ Root â†’ Right) â†’ Root splits the array into left and right subtrees.
3. Use a HashMap (inorder_map) for quick lookup instead of searching in inorder each time.

ðŸ“Œ Step-by-Step Algorithm  

1ï¸âƒ£ Precompute HashMap for inorder
Create a dictionary {value: index} from inorder for O(1) lookup.  

2ï¸âƒ£ Use Recursion to Build the Tree
Pick the root from preorder[index], then move to the next element (index += 1).
Find the root in inorder_map to determine left and right subtree ranges.
Recursively build left and right subtrees.  

3ï¸âƒ£ Base Case
If left > right (no elements left), return None.

```python
preorder = [3,9,20,15,7];inorder = [9,3,15,20,7]

class TreeNode:
     def __init__(self, val=0, left=None, right=None):
         self.val = val
         self.left = left
         self.right = right

def constructTree(preorder,inorder):

    inorder_map = {val:i for i,val in enumerate(inorder)}

    index = 0

    def buildtree(left,right):

        nonlocal index
        if left > right:

            return

        val = preorder[index]
        index += 1
        inorder_index = inorder_map[val]

        node = TreeNode(val)

        left = buildtree(left,inorder_index-1)
        right  = buildtree(inorder_index+1,right)

        node.left = left
        node.right = right

        return node

    return buildtree(0,len(inorder)-1)


root = constructTree(preorder,inorder)

```

Time Complexity --> O(n)  
Space Complexity --> O(n)
